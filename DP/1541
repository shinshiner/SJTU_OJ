/*
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right.
You can only see the k numbers in the window. Each time the sliding window moves right by one position.
For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.
Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7
Therefore, return the max sliding window as [3,3,5,5,6,7].
Note: You may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.

input 3 rows, the first rows is a number k and the second rows is a number n.
The third row is n numbers separated by a blank.

output n-k+1 numbers in a row separated by a blank.
*/

//区间最大问题用单调队列解
#include <iostream>
#include <cstdio>

using namespace std;

long long a[210000], q[300000];

int main()
{
    int n, k, i, head=0, tail=0;
    cin >> k >> n;
    for(i=0;i<n;++i) cin >> a[i];
    for(i=0;i<k;++i){
        if(head==tail) {q[tail++] = i; continue;}
        while(head!=tail&&a[i]>a[q[tail-1]]) --tail;
        q[tail++] = i;
    }
    for(i=0;i<n-k+1;++i){
        cout << a[q[head]] << ' ';
        if(q[head]<=i) head++;
        if(head==tail) {q[tail++] = i + k; continue;}
        while(head!=tail&&a[i+k]>a[q[tail-1]]) --tail;
        q[tail++] = i + k;
    }
    return 0;
}
